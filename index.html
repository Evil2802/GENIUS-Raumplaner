<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GENIUS Nachhilfe - Raumplanung</title>
<style>
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
margin: 0; padding: 0;
background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
color: #333;
min-height: 100vh;
display: flex;
flex-direction: column;
}
header {
background: #bcaaa4;
color: white;
padding: 15px 20px;
text-align: center;
box-shadow: 0 2px 6px rgba(0,0,0,0.2);
border-bottom-left-radius: 15px;
border-bottom-right-radius: 15px;
}
header h1 {
font-size: 1.5rem;
font-weight: 700;
margin: 0;
}
header p {
font-size: 0.9rem;
font-weight: 400;
margin-top: 5px;
color: rgba(255, 255, 255, 0.8);
}
main {
flex: 1;
max-width: 900px;
margin: 20px auto;
background: white;
border-radius: 12px;
padding: 20px 25px;
box-shadow: 0 6px 15px rgba(0,0,0,0.1);
}
.login, .register, .dashboard, .adminPanel { /* Added .register */
margin-top: 20px;
padding: 15px;
border-radius: 10px;
background-color: #fcfcfc;
box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
.login, .register { /* Centered login/register elements */
text-align: center;
}
.login input[type="text"],
.login input[type="email"],
.login input[type="password"],
.register input[type="text"],
.register input[type="email"],
.register input[type="password"] {
margin-bottom: 15px;
display: block; /* Make inputs block-level for better stacking */
width: calc(100% - 24px); /* Adjust width for padding */
max-width: 320px;
margin-left: auto; /* Center inputs */
margin-right: auto; /* Center inputs */
}
.login button,
.register button {
margin-top: 5px; /* Space above buttons */
}
.form-switch-link { /* Style for switch links */
margin-top: 15px;
font-size: 0.9em;
cursor: pointer;
color: #bcaaa4;
text-decoration: underline;
}
.form-switch-link:hover {
color: #a1887f;
}

input[type="text"],
input[type="email"],
input[type="password"] {
padding: 10px 12px;
font-size: 1rem;
border: 2px solid #bcaaa4;
border-radius: 8px;
}
button {
background-color: #bcaaa4;
color: white;
border: none;
padding: 12px 22px;
font-size: 1.05rem;
border-radius: 10px;
cursor: pointer;
transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
box-shadow: 0 4px 8px rgba(188,170,164,0.3);
}
button:hover {
background-color: #a1887f;
transform: translateY(-2px);
box-shadow: 0 6px 12px rgba(188,170,164,0.4);
}
h2 {
margin-bottom: 12px;
color: #555;
text-align: center;
}
.current-user-info {
background-color: #e0e0e0;
padding: 10px 20px;
border-radius: 10px;
margin-bottom: 20px;
font-size: 1rem;
text-align: center;
color: #555;
box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.error {
color: #c62828;
margin: 10px 0;
font-weight: 600;
}
table {
width: 100%;
border-collapse: collapse;
margin-top: 12px;
font-size: 0.9rem;
}
th, td {
border: 1px solid #ddd;
padding: 8px 6px;
text-align: center;
}
th {
background: #f5f5f5;
}
.date-grid {
display: grid;
grid-template-columns: repeat(auto-fill,minmax(120px,1fr));
gap: 12px;
margin-top: 15px;
}
.date-tile {
background: #f5f5f5;
padding: 10px 0;
border-radius: 10px;
cursor: pointer;
user-select: none;
box-shadow: 0 3px 6px rgba(188,170,164,0.2);
transition: background-color 0.25s ease, transform 0.2s ease;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
}
.date-tile .date-day-number {
font-size: 1.5rem;
font-weight: 700;
color: #bcaaa4;
line-height: 1;
margin-bottom: 5px;
}
.date-tile .date-weekday-abbr {
font-size: 0.9rem;
font-weight: 500;
color: #666;
}
.date-tile .date-month-abbr {
font-size: 0.8rem;
font-weight: 400;
color: #888;
margin-top: 3px;
}
.date-tile:hover {
background: #e0e0e0;
transform: translateY(-2px);
}
.date-tile.selected {
background: #bcaaa4;
color: white;
font-weight: 600;
}
.date-tile.selected .date-day-number,
.date-tile.selected .date-weekday-abbr,
.date-tile.selected .date-month-abbr {
color: white;
}

.room-selection {
display: flex;
justify-content: center;
gap: 15px;
flex-wrap: wrap;
margin-bottom: 20px;
}
.room-selection label {
background-color: #f0f0f0;
padding: 10px 20px;
border-radius: 10px;
cursor: pointer;
transition: background-color 0.25s ease, border 0.25s ease;
border: 2px solid transparent;
font-weight: 500;
box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.room-selection input[type="radio"] {
display: none;
}
.room-selection input[type="radio"]:checked + label {
background-color: #bcaaa4;
color: white;
border: 2px solid #a1887f;
box-shadow: 0 4px 8px rgba(188,170,164,0.3);
}
.room-selection label:hover {
background-color: #e5e5e5;
}

.time-slots {
margin-top: 20px;
display: grid; /* Changed to grid */
grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); /* Auto-fill columns */
gap: 15px;
/* flex-wrap: wrap; Removed as grid handles wrapping */
}
.slot {
/* flex: 1 1 90px; Removed flex properties as using grid */
min-width: 90px;
background-color: #e0e0e0;
color: #333;
padding: 8px 6px;
border-radius: 8px;
font-weight: 600;
cursor: pointer;
user-select: none;
text-align: center;
box-shadow: 0 3px 8px rgba(188,170,164,0.4);
transition: background-color 0.25s ease, transform 0.2s ease;
}
.slot.booked {
background-color: #ef9a9a;
cursor: not-allowed;
color: #333;
}
.slot.own {
background-color: #a5d6a7;
cursor: pointer;
color: #333;
}
.slot:hover:not(.booked):not(.own) {
background-color: #c0c0c0;
transform: translateY(-2px);
}
.slot.booked.admin-override {
background-color: #fdd835;
color: #333;
cursor: pointer;
}
.slot.booked.admin-override:hover {
background-color: #fbc02d;
}
.adminPanel {
margin-top: 30px;
border-top: 2px solid #bcaaa4;
padding-top: 20px;
}
/* Removed .whitelist-management and its children styles */

.user-management {
margin-top: 20px;
padding-top: 15px;
border-top: 1px solid #ddd;
}
.user-management ul {
list-style: none;
padding: 0;
}
.user-management li {
background: #fcfcfc;
margin: 5px 0;
padding: 10px 15px;
border-radius: 8px;
display: flex;
justify-content: space-between;
align-items: center;
box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.user-management button {
padding: 6px 12px;
font-size: 0.9rem;
}
.delete-account-container { /* New style for delete account button container */
text-align: right;
margin-top: 20px;
padding-top: 10px;
border-top: 1px solid #eee;
}
footer {
text-align: center;
padding: 12px 0;
color: #666;
font-size: 0.9rem;
}

/* Custom Modal Styles */
#customModal {
display: none;
position: fixed;
z-index: 1000;
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: auto;
background-color: rgba(0,0,0,0.5);
justify-content: center;
align-items: center;
}

#customModal .modal-content {
background-color: #fefefe;
margin: auto;
padding: 20px;
border: 1px solid #888;
width: 80%;
max-width: 400px;
border-radius: 10px;
box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
text-align: center;
position: relative;
}

#customModal .modal-content button {
margin: 5px;
min-width: 80px;
}

#customModal .modal-content button#modalCancelBtn {
background-color: #666;
}
#customModal .modal-content button#modalCancelBtn:hover {
background-color: #555;
}

</style>
</head>
<body>

<header>
<h1>GENIUS Nachhilfe - Raumplanung</h1>
<p>Wolfgang-Heinze-Straße 6b, 18435 Stralsund</p>
</header>

<main>

<section class="login" id="loginSection">
<h2>Login</h2>
<input type="email" id="loginEmailInput" placeholder="E-Mail" />
<input type="password" id="loginPasswordInput" placeholder="Passwort" />
<button id="loginBtn">Einloggen</button>
<p class="error" id="loginError" style="display:none;"></p>
<p class="form-switch-link" id="showRegisterLink">Noch kein Konto? Registrieren</p>
</section>

<section class="register" id="registerSection" style="display:none;">
<h2>Registrieren</h2>
<input type="text" id="registerNameInput" placeholder="Dein Name (z.B. Anna Müller)" />
<input type="email" id="registerEmailInput" placeholder="E-Mail" />
<input type="password" id="registerPasswordInput" placeholder="Passwort" />
<input type="password" id="registerConfirmPasswordInput" placeholder="Passwort wiederholen" />
<button id="registerBtn">Registrieren</button>
<p class="error" id="registerError" style="display:none;"></p>
<p class="form-switch-link" id="showLoginLink">Bereits ein Konto? Anmelden</p>
</section>

<section class="dashboard" style="display:none;">
<div class="current-user-info">
Du bist eingeloggt als: <span id="userNameDisplay"></span>
<span id="userApprovalStatus" style="margin-left: 10px; font-weight: bold;"></span>
</div>
<h2>Termin buchen</h2>
<p>Klicke auf ein Datum, um Zeiten zu sehen und dich ein- oder auszutragen.</p>
<div class="room-selection">
<input type="radio" id="room1" name="room" value="Raum 1" checked>
<label for="room1">Raum 1</label>
<input type="radio" id="room2" name="room" value="Raum 2">
<label for="room2">Raum 2</label>
</div>
<div id="datesContainer" class="date-grid"></div>
<div id="timeSlotsContainer" class="time-slots" style="display:none;"></div>
<button id="logoutBtn" style="margin-top:15px;">Ausloggen</button>
<div class="delete-account-container"> <button id="deleteAccountBtn" style="background:#c62828;">Konto löschen</button>
</div>
</section>

<section class="adminPanel" style="display:none;">
<h2>Admin-Bereich</h2>
<button id="clearAllBookingsBtn" style="background:#ef5350;">Alle Buchungen löschen</button>

<div class="user-management">
<h3>Benutzer-Verwaltung (Genehmigung)</h3>
<p>Hier können Administratoren den Genehmigungsstatus der Benutzer verwalten. Nur genehmigte Benutzer können Termine buchen.</p>
<ul id="userList"></ul>
</div>
</section>

<div id="customModal">
<div class="modal-content">
<p id="modalMessage"></p>
<button id="modalConfirmBtn">Ja</button>
<button id="modalCancelBtn">Abbrechen</button>
<button id="modalOKBtn">OK</button>
</div>
</div>

</main>

<footer>© 2025 Dein Raumplaner</footer>

<script type="module">
// Corrected Firebase imports for modular SDK
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, reauthenticateWithCredential, EmailAuthProvider, deleteUser } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js"; // Added reauthenticateWithCredential, EmailAuthProvider, deleteUser
import { getFirestore, doc, getDoc, setDoc, deleteDoc, collection, onSnapshot, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js"; // Removed addDoc, since whitelist_teachers is removed

// === Firebase-Konfiguration ===
// Wichtiger Hinweis: Wenn Sie den Fehler "auth/configuration-not-found" erhalten,
// stellen Sie sicher, dass "Email/Password" als Anmeldemethode in Ihrem Firebase-Projekt
// (Authentication -> Sign-in method) aktiviert ist.
const firebaseConfig = {
apiKey: "AIzaSyApOdRm_xgUhPbeBeFJ6NPHOt4LSBUJiIo", // ERSETZEN SIE DIES MIT IHREM EIGENEN API-SCHLÜSSEL
authDomain: "genius-raumplaner.firebaseapp.com",
databaseURL: "https://genius-raumplaner-default-rtdb.europe-west1.firebasedatabase.app",
projectId: "genius-raumplaner",
storageBucket: "genius-raumplaner.firebasestorage.app",
messagingSenderId: "1081346940014",
appId: "1:1081346940014:web:d6b00e0f7d3cd1fb125a7f"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// === Globale Variablen ===
let currentUser = null; // Stores authenticated user's display name
let currentUserEmail = null; // Stores authenticated user's email
let isAdmin = false;
let currentUserData = null; // Stores the full user document data from Firestore
const DAYS_TO_SHOW = 30;
let selectedDate = null;
let selectedRoom = 'Raum 1';

// Hardcoded admin names for explicit admin rights (for UI logic only)
// The actual admin check for security is done in Firestore Rules using UID.
// Make sure these names match the names of the UIDs you configure in Firestore Rules.
const ADMIN_NAMES = ["sascha birk", "jeanin birk", "nora"]; // Stellen Sie sicher, dass diese Namen den in Firestore gespeicherten Namen entsprechen (kleingeschrieben)

// === Utility function to capitalize the first letter of each word ===
function toTitleCase(str) {
if (!str) return '';
return str.split(' ').map(word => {
if (word.length === 0) return '';
return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
}).join(' ');
}

// === Custom Modal Functions ===
let resolveModalPromise;

function showModal(message, type = 'alert', onConfirm = null) {
const customModal = document.getElementById('customModal');
const modalMessage = document.getElementById('modalMessage');
const modalConfirmBtn = document.getElementById('modalConfirmBtn');
const modalCancelBtn = document.getElementById('modalCancelBtn');
const modalOKBtn = document.getElementById('modalOKBtn');

modalMessage.textContent = message;

modalConfirmBtn.style.display = 'none';
modalCancelBtn.style.display = 'none';
modalOKBtn.style.display = 'none';

return new Promise(resolve => {
resolveModalPromise = resolve;

if (type === 'confirm') {
modalConfirmBtn.style.display = 'inline-block';
modalCancelBtn.style.display = 'inline-block';
modalConfirmBtn.onclick = () => {
customModal.style.display = 'none';
resolveModalPromise(true);
if (onConfirm) onConfirm();
};
modalCancelBtn.onclick = () => {
customModal.style.display = 'none';
resolveModalPromise(false);
};
} else { // 'alert'
modalOKBtn.style.display = 'inline-block';
modalOKBtn.onclick = () => {
customModal.style.display = 'none';
resolveModalPromise(true);
};
}
customModal.style.display = 'flex';
});
}

// === Firebase Auth State Listener ===
onAuthStateChanged(auth, async (user) => {
if (user) {
currentUserEmail = user.email;

const userDocRef = doc(db, 'users', user.uid);
const userDocSnap = await getDoc(userDocRef);

if (userDocSnap.exists()) {
currentUserData = userDocSnap.data(); // Store all user data including isApproved
currentUser = currentUserData.name;
// Check if current user's UID is one of the hardcoded admin UIDs (requires async check or pre-populated list)
// For client-side UI, we'll use the ADMIN_NAMES list for display purposes.
// The actual security is handled by Firestore Rules based on UID.
isAdmin = ADMIN_NAMES.includes(currentUser.toLowerCase());
} else {
console.warn("User document not found for authenticated user:", user.uid);
// If user document doesn't exist, sign them out as a security measure/cleanup
await signOut(auth);
return;
}

localStorage.setItem('currentUserUid', user.uid);
localStorage.setItem('currentUser', currentUser);
localStorage.setItem('isAdmin', isAdmin); // This is for UI, actual security by Firestore rules
localStorage.setItem('currentUserData', JSON.stringify(currentUserData)); // Store full data

showDashboard();

// Listen for real-time updates to the user's own document (especially isApproved)
onSnapshot(userDocRef, (doc) => {
if (doc.exists()) {
const prevIsApproved = currentUserData.isApproved;
currentUserData = doc.data();
isAdmin = ADMIN_NAMES.includes(currentUserData.name.toLowerCase()); // Re-evaluate admin for UI

// If approval status changed, refresh UI for user
if (prevIsApproved !== currentUserData.isApproved) {
showModal(`Dein Genehmigungsstatus wurde ${currentUserData.isApproved ? 'aktiviert' : 'deaktiviert'}.`).then(() => {
if (selectedDate) {
selectDate(selectedDate); // Re-render time slots if approval status changes
}
updateUserApprovalStatusDisplay(); // Update display for current user
});
} else if (selectedDate) {
// If selectedDate is already set and other data changed (e.g., name), re-render
selectDate(selectedDate);
}
updateUserApprovalStatusDisplay(); // Always update display when user data loads/changes
}
});

} else {
currentUser = null;
currentUserEmail = null;
isAdmin = false;
currentUserData = null; // Clear user data
localStorage.removeItem('currentUserUid');
localStorage.removeItem('currentUser');
localStorage.removeItem('isAdmin');
localStorage.removeItem('currentUserData');
showLogin();
}
});

// Helper to update the approval status display in the dashboard
const userApprovalStatusDisplay = document.getElementById('userApprovalStatus');
function updateUserApprovalStatusDisplay() {
// Only show approval status if not an admin
if (isAdmin) {
userApprovalStatusDisplay.textContent = "";
return;
}

if (currentUserData) {
if (currentUserData.isApproved) {
userApprovalStatusDisplay.textContent = "(Genehmigt)";
userApprovalStatusDisplay.style.color = "#2e7d32"; // Green
} else {
userApprovalStatusDisplay.textContent = "(Warten auf Genehmigung)";
userApprovalStatusDisplay.style.color = "#d32f2f"; // Red
}
} else {
userApprovalStatusDisplay.textContent = "";
}
}

// Lade Buchungen für Datum und Raum (Firestore)
async function loadBookings(dateStr, room) {
const bookingDocRef = doc(db, 'bookings', dateStr, 'rooms', room);
const docSnap = await getDoc(bookingDocRef);
return docSnap.exists() ? docSnap.data() : {};
}

// Buchung speichern / löschen (Firestore)
async function toggleBooking(dateStr, room, timeSlot, userDisplayName, isAdminUser) {
// Clientseitige Prüfung: Nur genehmigte Nutzer oder Admins dürfen buchen
if (!currentUserData || (!currentUserData.isApproved && !isAdminUser)) {
await showModal("Du bist noch nicht genehmigt, um Termine zu buchen. Bitte kontaktiere den Administrator.");
return;
}

const bookingDocRef = doc(db, 'bookings', dateStr, 'rooms', room);
const currentBookings = await loadBookings(dateStr, room);

if (currentBookings[timeSlot] && currentBookings[timeSlot].toLowerCase() === userDisplayName.toLowerCase()) {
// Nutzer löscht eigenen Slot - keine Bestätigung nötig
delete currentBookings[timeSlot];
await setDoc(bookingDocRef, currentBookings);
await showModal("Deine Buchung wurde erfolgreich storniert.");
return null;
} else if (currentBookings[timeSlot] && isAdminUser) {
// Admin löscht Slot eines anderen Nutzers - keine Bestätigung nötig
const bookedBy = toTitleCase(currentBookings[timeSlot]);
delete currentBookings[timeSlot];
await setDoc(bookingDocRef, currentBookings);
await showModal(`Buchung von ${bookedBy} wurde erfolgreich gelöscht.`);
return null;
} else if (!currentBookings[timeSlot]) {
// Slot ist frei, buchen - keine Bestätigung nötig
currentBookings[timeSlot] = userDisplayName; // Namen speichern (konsistent kleingeschrieben von der Registrierung)
await setDoc(bookingDocRef, currentBookings);
await showModal(`Dein Termin um ${timeSlot} wurde erfolgreich gebucht.`);
return userDisplayName;
} else {
// Slot ist von jemand anderem gebucht (und es ist kein Admin, der löschen will)
await showModal(`Dieser Termin ist bereits von ${toTitleCase(currentBookings[timeSlot])} gebucht!`);
return currentBookings[timeSlot];
}
}

// NEU: Funktion zum Löschen von Buchungen eines bestimmten Benutzers (für Kontolöschung)
async function clearUserBookings(userDisplayName) {
const bookingsCollectionRef = collection(db, 'bookings');
const bookingsSnapshot = await getDocs(bookingsCollectionRef); // Alle Datumsdokumente abrufen

const batch = writeBatch(db);
let bookingsRemovedCount = 0;

for (const dateDoc of bookingsSnapshot.docs) {
const dateStr = dateDoc.id;
const roomsCollectionRef = collection(db, 'bookings', dateStr, 'rooms');
const roomsSnapshot = await getDocs(roomsCollectionRef); // Alle Raumdokumente für dieses Datum abrufen

for (const roomDoc of roomsSnapshot.docs) {
const roomName = roomDoc.id;
const currentBookings = roomDoc.data();
let changed = false;
const newBookings = { ...currentBookings };

for (const slot in newBookings) {
if (newBookings[slot].toLowerCase() === userDisplayName.toLowerCase()) {
delete newBookings[slot];
changed = true;
bookingsRemovedCount++;
}
}
if (changed) {
// Wenn keine Slots mehr vorhanden sind, lösche das Raumdokument
if (Object.keys(newBookings).length === 0) {
batch.delete(doc(db, 'bookings', dateStr, 'rooms', roomName));
} else {
batch.set(doc(db, 'bookings', dateStr, 'rooms', roomName), newBookings);
}
}
}
}
await batch.commit();
return bookingsRemovedCount;
}

// Alle Buchungen löschen (Admin) (Firestore)
async function clearAllBookings() {
const confirmed = await showModal("Alle Buchungen wirklich löschen? Dies kann nicht rückgängig gemacht werden.", 'confirm');
if (confirmed) {
const bookingsCollectionRef = collection(db, 'bookings');
const querySnapshot = await getDocs(bookingsCollectionRef);
const batch = writeBatch(db); // Use batch for efficiency
for (const dateDoc of querySnapshot.docs) {
const roomsCollectionRef = collection(db, 'bookings', dateDoc.id, 'rooms');
const roomsSnapshot = await getDocs(roomsCollectionRef);
for (const roomDoc of roomsSnapshot.docs) {
batch.delete(roomDoc.ref); // Delete each room document
}
// Optionally, delete the date document itself if all rooms are empty,
// but deleting subcollections is usually enough. For simplicity here,
// we just delete the room docs. If the date doc contains other data,
// you might want to consider clearing its fields instead of deleting it.
}
await batch.commit(); // Commit all deletions
await showModal("Alle Buchungen wurden gelöscht.");
if (selectedDate) { // Refresh current view
bookingsForSelectedDate = await loadBookings(selectedDate, selectedRoom);
renderTimeSlots();
}
}
}

// Hilfsfunktion: Datum alsenthalt-MM-DD formatieren (for internal use)
function formatDate(date) {
return date.toISOString().split('T')[0];
}

// Hilfsfunktion: Wochentag als Text (for display)
function getWeekday(date) {
const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
return days[date.getDay()];
}

// Hilfsfunktion: Monat als Abkürzung
function getMonthAbbreviation(date) {
const months = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
return months[date.getMonth()];
}

// Datumsliste generieren
function generateDateList() {
const dates = [];
const today = new Date();
for (let i = 0; i < DAYS_TO_SHOW; i++) {
const d = new Date(today);
d.setDate(today.getDate() + i);
dates.push(d);
}
return dates;
}

// UI Elemente
const loginSection = document.getElementById('loginSection');
const registerSection = document.getElementById('registerSection');
const dashboardSection = document.querySelector('.dashboard');
const adminSection = document.querySelector('.adminPanel');

const loginEmailInput = document.getElementById('loginEmailInput');
const loginPasswordInput = document.getElementById('loginPasswordInput');
const loginBtn = document.getElementById('loginBtn');
const loginError = document.getElementById('loginError');

const registerNameInput = document.getElementById('registerNameInput');
const registerEmailInput = document.getElementById('registerEmailInput');
const registerPasswordInput = document.getElementById('registerPasswordInput');
const registerConfirmPasswordInput = document.getElementById('registerConfirmPasswordInput');
const registerBtn = document.getElementById('registerBtn');
const registerError = document.getElementById('registerError');

const showRegisterLink = document.getElementById('showRegisterLink');
const showLoginLink = document.getElementById('showLoginLink');

const userNameDisplay = document.getElementById('userNameDisplay');
const datesContainer = document.getElementById('datesContainer');
const timeSlotsContainer = document.getElementById('timeSlotsContainer');
const logoutBtn = document.getElementById('logoutBtn');
const deleteAccountBtn = document.getElementById('deleteAccountBtn'); // NEW: Delete account button

const clearAllBookingsBtn = document.getElementById('clearAllBookingsBtn');
// Removed elements related to whitelist-management

const userList = document.getElementById('userList'); // NEW: For user approval management
const room1Radio = document.getElementById('room1');
const room2Radio = document.getElementById('room2');

let bookingsForSelectedDate = {};

// Initial view setup
function showLogin() {
loginSection.style.display = 'block';
registerSection.style.display = 'none';
dashboardSection.style.display = 'none';
adminSection.style.display = 'none';
loginError.style.display = 'none';
registerError.style.display = 'none';
}

function showRegister() {
loginSection.style.display = 'none';
registerSection.style.display = 'block';
dashboardSection.style.display = 'none';
adminSection.style.display = 'none';
loginError.style.display = 'none';
registerError.style.display = 'none';
}

// Login logic
loginBtn.onclick = async () => {
const email = loginEmailInput.value.trim();
const password = loginPasswordInput.value.trim();
loginError.style.display = 'none';

if (!email || !password) {
loginError.textContent = "Bitte E-Mail und Passwort eingeben.";
loginError.style.display = 'block';
return;
}

try {
await signInWithEmailAndPassword(auth, email, password);
// onAuthStateChanged will handle UI update
} catch (error) {
console.error("Login Error:", error.code, error.message);
let errorMessage = "Anmeldung fehlgeschlagen. Überprüfen Sie Ihre E-Mail und Ihr Passwort.";
if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
errorMessage = "Ungültige E-Mail oder falsches Passwort.";
} else if (error.code === 'auth/invalid-email') {
errorMessage = "Ungültiges E-Mail-Format.";
}
loginError.textContent = errorMessage;
loginError.style.display = 'block';
}
};

// Registration logic
registerBtn.onclick = async () => {
const name = registerNameInput.value.trim();
const email = registerEmailInput.value.trim();
const password = registerPasswordInput.value.trim();
const confirmPassword = registerConfirmPasswordInput.value.trim();
registerError.style.display = 'none';

if (!name || !email || !password || !confirmPassword) {
registerError.textContent = "Bitte füllen Sie alle Felder aus.";
registerError.style.display = 'block';
return;
}
if (password.length < 6) {
registerError.textContent = "Passwort muss mindestens 6 Zeichen lang sein.";
registerError.style.display = 'block';
return;
}
if (password !== confirmPassword) {
registerError.textContent = "Passwörter stimmen nicht überein.";
registerError.style.display = 'block';
return;
}

try {
const userCredential = await createUserWithEmailAndPassword(auth, email, password);
const user = userCredential.user;

// Save user's name to Firestore 'users' collection with isApproved: false
// Store name in lowercase to ensure consistent comparison with rules
await setDoc(doc(db, 'users', user.uid), {
name: name.toLowerCase(), // Store name in lowercase
email: email,
uid: user.uid,
isTeacher: true, // All registered users are teachers by default
isApproved: false // User is unapproved by default by default
});

await showModal("Registrierung erfolgreich! Sie sind jetzt angemeldet. Bitte warten Sie auf die Genehmigung durch einen Administrator, um Termine buchen zu können."); // Message updated
// onAuthStateChanged will handle UI update
} catch (error) {
console.error("Registration Error:", error.code, error.message);
let errorMessage = "Registrierung fehlgeschlagen.";
if (error.code === 'auth/email-already-in-use') {
errorMessage = "Diese E-Mail-Adresse ist bereits registriert.";
} else if (error.code === 'auth/invalid-email') {
errorMessage = "Ungültiges E-Mail-Format.";
} else if (error.code === 'auth/weak-password') {
errorMessage = "Passwort ist zu schwach (min. 6 Zeichen).";
} else if (error.code === 'auth/configuration-not-found') {
errorMessage = "Registrierung fehlgeschlagen. Bitte aktivieren Sie die 'Email/Password'-Anmeldemethode in Ihrer Firebase Console unter 'Authentication' -> 'Sign-in method'.";
}
registerError.textContent = errorMessage;
registerError.style.display = 'block';
}
};

// Toggle between login and register forms
showRegisterLink.onclick = showRegister;
showLoginLink.onclick = showLogin;

// Logout
logoutBtn.onclick = async () => {
try {
await signOut(auth);
// onAuthStateChanged will handle UI update
await showModal("Sie wurden erfolgreich abgemeldet.");
} catch (error) {
console.error("Logout Error:", error.message);
await showModal("Fehler beim Abmelden: " + error.message);
}
};

// NEW: Delete current user's account
deleteAccountBtn.onclick = async () => {
if (!auth.currentUser) {
await showModal("Sie sind nicht angemeldet.");
return;
}

const confirmed = await showModal("Möchten Sie Ihr Konto wirklich löschen? Dies kann nicht rückgängig gemacht werden. Alle Ihre Daten und Buchungen werden gelöscht.", 'confirm');
if (!confirmed) {
return;
}

const email = currentUserEmail; // Get email from the current session
const password = prompt("Bitte geben Sie Ihr Passwort zur Bestätigung ein:"); // Prompt for password for re-authentication

if (!password) {
await showModal("Passwort zur Bestätigung erforderlich.");
return;
}

try {
const credential = EmailAuthProvider.credential(email, password);
await reauthenticateWithCredential(auth.currentUser, credential);

const userUid = auth.currentUser.uid;
const userDisplayName = currentUser;

// 1. Delete user's document from 'users' collection
await deleteDoc(doc(db, 'users', userUid));

// 2. Clear all bookings made by this user
await clearUserBookings(userDisplayName);

// 3. Delete the Firebase Authentication account
await deleteUser(auth.currentUser);

await showModal("Ihr Konto und alle zugehörigen Daten wurden erfolgreich gelöscht.");
// onAuthStateChanged will handle UI update and sign out
} catch (error) {
console.error("Account deletion error:", error.code, error.message);
let errorMessage = "Fehler beim Löschen des Kontos.";
if (error.code === 'auth/requires-recent-login') {
errorMessage = "Diese Aktion erfordert eine kürzliche Anmeldung. Bitte melden Sie sich erneut an und versuchen Sie es noch einmal.";
} else if (error.code === 'auth/wrong-password') {
errorMessage = "Falsches Passwort. Konto konnte nicht gelöscht werden.";
} else if (error.code === 'auth/user-mismatch' || error.code === 'auth/invalid-credential') {
errorMessage = "Ungültige Anmeldeinformationen für die Reauthentifizierung.";
} else if (error.code === 'auth/network-request-failed') {
errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
}
await showModal(errorMessage);
}
};


// Dashboard anzeigen
function showDashboard() {
loginSection.style.display = 'none';
registerSection.style.display = 'none';
dashboardSection.style.display = 'block';
adminSection.style.display = isAdmin ? 'block' : 'none';
userNameDisplay.textContent = toTitleCase(currentUser);
updateUserApprovalStatusDisplay(); // Update approval status on dashboard load

renderDates();
if (selectedDate) {
selectDate(selectedDate);
}
if (isAdmin) {
renderUserList(); // Call to render the list of users in admin panel
}
}

// Datumskacheln rendern
function renderDates() {
datesContainer.innerHTML = '';
const dates = generateDateList();

dates.forEach(date => {
const dateStr = formatDate(date);
const dayNumber = String(date.getDate()).padStart(2, '0');
const weekdayAbbr = getWeekday(date);
const monthAbbr = getMonthAbbreviation(date);

const div = document.createElement('div');
div.className = 'date-tile';
div.dataset.date = dateStr;

const daySpan = document.createElement('span');
daySpan.className = 'date-day-number';
daySpan.textContent = dayNumber;

const weekdaySpan = document.createElement('span');
weekdaySpan.className = 'date-weekday-abbr';
weekdaySpan.textContent = weekdayAbbr;

const monthSpan = document.createElement('span');
monthSpan.className = 'date-month-abbr';
monthSpan.textContent = monthAbbr;

div.appendChild(daySpan);
div.appendChild(weekdaySpan);
div.appendChild(monthSpan);

div.onclick = () => selectDate(dateStr);

datesContainer.appendChild(div);
});
}

// Datum auswählen
async function selectDate(dateStr) {
selectedDate = dateStr;
highlightSelectedDate();

bookingsForSelectedDate = await loadBookings(selectedDate, selectedRoom);
renderTimeSlots();
}

// Hervorheben des gewählten Datums
function highlightSelectedDate() {
[...datesContainer.children].forEach(div => {
div.classList.toggle('selected', div.dataset.date === selectedDate);
});
}

// Slots von 6:00 bis 20:00 im 30-Minuten-Takt generieren
function generateTimeSlots() {
const slots = [];
for (let h = 6; h <= 20; h++) {
slots.push(`${String(h).padStart(2, '0')}:00`);
if (h < 20) {
slots.push(`${String(h).padStart(2, '0')}:30`);
}
}
return slots;
}

// Zeit-Slots rendern
function renderTimeSlots() {
timeSlotsContainer.innerHTML = '';
timeSlotsContainer.style.display = 'grid'; // Ensure grid display for consistency

const slots = generateTimeSlots();

slots.forEach(slot => {
const bookingUser = bookingsForSelectedDate[slot];
const slotDiv = document.createElement('div');
slotDiv.className = 'slot';

if (bookingUser) {
slotDiv.textContent = toTitleCase(bookingUser);
if (currentUser && bookingUser.toLowerCase() === currentUser.toLowerCase()) {
slotDiv.classList.add('own');
slotDiv.title = 'Klicke zum Austragen';
} else if (isAdmin) { // Admin can override
slotDiv.classList.add('booked', 'admin-override');
slotDiv.title = `Gebucht von ${toTitleCase(bookingUser)} (Klicke zum Löschen)`;
} else { // Booked by someone else, not admin
slotDiv.classList.add('booked');
slotDiv.title = 'Bereits gebucht';
}
} else {
slotDiv.textContent = slot;
// Only allow click if approved or admin
if (currentUserData && currentUserData.isApproved || isAdmin) {
slotDiv.title = 'Klicke zum Eintragen';
} else {
slotDiv.title = 'Nicht genehmigt (zum Buchen Administrator kontaktieren)';
slotDiv.style.cursor = 'not-allowed'; // Visually indicate not clickable
slotDiv.classList.add('booked'); // Grey out slightly if not approved
}
}

// Only make clickable if appropriate permissions (approved user or admin)
if (currentUserData && (currentUserData.isApproved || isAdmin) && (!bookingUser || bookingUser.toLowerCase() === currentUser.toLowerCase() || isAdmin)) {
slotDiv.style.cursor = 'pointer';
slotDiv.onclick = async () => {
if (!currentUser) { // Should not happen with onAuthStateChanged but as a fallback
await showModal("Bitte logge dich zuerst ein, um einen Slot zu buchen.");
return;
}
// The toggleBooking function itself now has the approval check
await toggleBooking(selectedDate, selectedRoom, slot, currentUser, isAdmin);
// Re-fetch and re-render time slots after any action
bookingsForSelectedDate = await loadBookings(selectedDate, selectedRoom);
renderTimeSlots();
};
} else if (!currentUserData || (!currentUserData.isApproved && !isAdmin)) {
slotDiv.onclick = () => showModal("Du bist noch nicht genehmigt, um Termine zu buchen. Bitte kontaktiere den Administrator.");
}

timeSlotsContainer.appendChild(slotDiv);
});
}

// Admin Button: Alle Buchungen löschen
clearAllBookingsBtn.onclick = async () => {
await clearAllBookings();
};

// NEW: Function to render all users (for admin panel approval)
async function renderUserList() {
if (!isAdmin) { // Only admins can see this section
userList.innerHTML = '';
return;
}
userList.innerHTML = '<li>Lade Benutzer...</li>';
const usersCollectionRef = collection(db, 'users');
const usersSnapshot = await getDocs(usersCollectionRef);

userList.innerHTML = '';
if (usersSnapshot.empty) {
userList.innerHTML = '<li>Keine Benutzer gefunden.</li>';
return;
}

usersSnapshot.forEach(userDoc => {
const userData = userDoc.data();
// Don't show the currently logged-in admin in this list for approval
if (userData.uid === auth.currentUser.uid) return;

const li = document.createElement('li');
li.style.display = 'flex';
li.style.justifyContent = 'space-between';
li.style.alignItems = 'center';
li.style.padding = '8px 10px';
li.style.margin = '5px 0';
li.style.backgroundColor = '#f0f0f0';
li.style.borderRadius = '8px';

const nameSpan = document.createElement('span');
nameSpan.textContent = toTitleCase(userData.name);
li.appendChild(nameSpan);

const statusSpan = document.createElement('span');
statusSpan.textContent = userData.isApproved ? 'Aktiviert' : 'Deaktiviert';
statusSpan.style.color = userData.isApproved ? '#2e7d32' : '#d32f2f';
statusSpan.style.fontWeight = 'bold';
li.appendChild(statusSpan);

const toggleBtn = document.createElement('button');
toggleBtn.textContent = userData.isApproved ? 'Deaktivieren' : 'Aktivieren';
toggleBtn.style.marginLeft = '10px';
toggleBtn.style.backgroundColor = userData.isApproved ? '#ef5350' : '#4caf50'; // Red for deactivate, green for activate
toggleBtn.onclick = async () => {
const confirmed = await showModal(`Möchtest du "${toTitleCase(userData.name)}" ${userData.isApproved ? 'deaktivieren' : 'aktivieren'}?`, 'confirm');
if (confirmed) {
try {
// Admin updates isApproved status of another user
await setDoc(doc(db, 'users', userDoc.id), { isApproved: !userData.isApproved }, { merge: true });
await showModal(`${toTitleCase(userData.name)} wurde ${userData.isApproved ? 'deaktiviert' : 'aktiviert'}.`);
renderUserList(); // Re-render list
} catch (error) {
console.error("Error toggling user approval:", error);
await showModal("Fehler beim Ändern des Status: " + error.message);
}
}
};
li.appendChild(toggleBtn);

userList.appendChild(li);
});
}

// Event listeners for room selection
room1Radio.addEventListener('change', () => {
selectedRoom = 'Raum 1';
if (selectedDate) {
selectDate(selectedDate);
}
});

room2Radio.addEventListener('change', () => {
selectedRoom = 'Raum 2';
if (selectedDate) {
selectDate(selectedDate);
}
});

// Initial load is handled by onAuthStateChanged, no need for separate init()
</script>
</body>
</html>
