<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GENIUS Nachhilfe - Raumplanung</title>
<style>
/* Basic Body and overall layout */
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
    color: #333;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header Styling */
header {
    background: #bcaaa4; /* Muted brown */
    color: white;
    padding: 15px 20px;
    text-align: center;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    border-bottom-left-radius: 15px;
    border-bottom-right-radius: 15px;
}
header h1 {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0;
}
header p {
    font-size: 0.9rem;
    font-weight: 400;
    margin-top: 5px;
    color: rgba(255, 255, 255, 0.8);
}

/* Main Content Area */
main {
    flex: 1; /* Allows main content to grow and take available space */
    max-width: 900px;
    margin: 20px auto; /* Centers the main content */
    background: white;
    border-radius: 12px;
    padding: 20px 25px;
    box-shadow: 0 6px 15px rgba(0,0,0,0.1);
}

/* Login, Register, Dashboard, Admin Panel Sections */
.login, .register, .dashboard, .adminPanel {
    margin-top: 20px;
    padding: 15px;
    border-radius: 10px;
    background-color: #fcfcfc;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
.login, .register {
    text-align: center; /* Centers content within login/register */
}

/* Input Fields Styling */
input[type="text"],
input[type="email"],
input[type="password"] {
    margin-bottom: 15px;
    display: block; /* Make inputs block-level for better stacking */
    width: calc(100% - 24px); /* Adjust width for padding */
    max-width: 380px; /* Increased max-width for registration name field to accommodate longer names */
    margin-left: auto; /* Center inputs */
    margin-right: auto; /* Center inputs */
    padding: 10px 12px;
    font-size: 1rem;
    border: 2px solid #bcaaa4; /* Muted brown border */
    border-radius: 8px;
    box-sizing: border-box; /* Include padding and border in the element's total width and height */
}

/* Button Styling */
button {
    background-color: #bcaaa4; /* Muted brown */
    color: white;
    border: none;
    padding: 12px 22px;
    font-size: 1.05rem;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    box-shadow: 0 4px 8px rgba(188,170,164,0.3); /* Subtle shadow for depth */
}
button:hover {
    background-color: #a1887f; /* Darker brown on hover */
    transform: translateY(-2px); /* Slight lift effect */
    box-shadow: 0 6px 12px rgba(188,170,164,0.4);
}

/* Form Switch Link (e.g., "Noch kein Konto? Registrieren") */
.form-switch-link {
    margin-top: 15px;
    font-size: 0.9em;
    cursor: pointer;
    color: #bcaaa4;
    text-decoration: underline;
}
.form-switch-link:hover {
    color: #a1887f;
}

/* Section Headings */
h2 {
    margin-bottom: 12px;
    color: #555;
    text-align: center;
}

/* Current User Info Display */
.current-user-info {
    background-color: #e0e0e0;
    padding: 10px 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    font-size: 1rem;
    text-align: center;
    color: #555;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    display: flex; /* Make it a flex container to align items */
    justify-content: space-between; /* Space out content and logout button */
    align-items: center; /* Align items vertically */
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
}

/* Adjusted logout button position within current-user-info */
.current-user-info #logoutBtn {
    margin-top: 0; /* Remove top margin from the button */
    margin-left: 15px; /* Add some space from the text */
    flex-shrink: 0; /* Prevent button from shrinking */
}

/* Error Message Styling */
.error {
    color: #c62828; /* Red for errors */
    margin: 10px 0;
    font-weight: 600;
}

/* Table Styling (if used) */
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 12px;
    font-size: 0.9rem;
}
th, td {
    border: 1px solid #ddd;
    padding: 8px 6px;
    text-align: center;
}
th {
    background: #f5f5f5;
}

/* Date Grid for Date Tiles */
.date-grid {
    display: grid;
    /* Responsive grid columns: minimum 120px, fills available space */
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 12px;
    margin-top: 15px;
}

/* Individual Date Tile Styling */
.date-tile {
    background: #f5f5f5;
    padding: 10px 0;
    border-radius: 10px;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 3px 6px rgba(188,170,164,0.2);
    transition: background-color 0.25s ease, transform 0.2s ease;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
.date-tile .date-day-number {
    font-size: 1.5rem;
    font-weight: 700;
    color: #bcaaa4; /* Muted brown */
    line-height: 1;
    margin-bottom: 5px;
}
.date-tile .date-weekday-abbr {
    font-size: 0.9rem;
    font-weight: 500;
    color: #666;
}
.date-tile .date-month-abbr {
    font-size: 0.8rem;
    font-weight: 400;
    color: #888;
    margin-top: 3px;
}
.date-tile:hover {
    background: #e0e0e0;
    transform: translateY(-2px);
}
.date-tile.selected {
    background: #bcaaa4; /* Muted brown when selected */
    color: white;
    font-weight: 600;
}
.date-tile.selected .date-day-number,
.date-tile.selected .date-weekday-abbr,
.date-tile.selected .date-month-abbr {
    color: white;
}

/* Room Selection Radio Buttons */
.room-selection {
    display: flex;
    justify-content: center;
    gap: 15px;
    flex-wrap: wrap; /* Allows wrapping on smaller screens */
    margin-bottom: 20px;
}
.room-selection label {
    background-color: #f0f0f0;
    padding: 10px 20px;
    border-radius: 10px;
    cursor: pointer;
    transition: background-color 0.25s ease, border 0.25s ease;
    border: 2px solid transparent;
    font-weight: 500;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.room-selection input[type="radio"] {
    display: none; /* Hide the default radio button */
}
.room-selection input[type="radio"]:checked + label {
    background-color: #bcaaa4; /* Muted brown when checked */
    color: white;
    border: 2px solid #a1887f; /* Darker brown border */
    box-shadow: 0 4px 8px rgba(188,170,164,0.3);
}
.room-selection label:hover {
    background-color: #e5e5e5;
}

/* Time Slots Grid */
.time-slots {
    margin-top: 20px;
    display: grid;
    /* Responsive grid columns: minimum 170px (slot width + padding), fills available space */
    grid-template-columns: repeat(auto-fill, minmax(170px, 1fr)); /* Adjusted min-width for proper spacing */
    gap: 20px; /* Increased space between grid items */
}

/* Individual Time Slot Styling */
.slot {
    width: 150px; /* Fixed content width */
    height: 75px; /* Slightly increased height */
    background-color: #e0e0e0;
    color: #333;
    padding: 8px 10px; /* Total width 150+10+10 = 170px */
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 3px 8px rgba(188,170,164,0.4);
    transition: background-color 0.25s ease, transform 0.2s ease;
    display: flex; /* Use flexbox for centering content */
    flex-direction: column; /* Stack content vertically (time then name) */
    justify-content: center; /* Center content vertically */
    align-items: center; /* Center content horizontally */
    overflow: hidden; /* Hide overflowing content, though wrapping should prevent most of it */
    box-sizing: border-box; /* Include padding in width/height */
    text-align: center; /* Default for all slots, content is centered by flexbox */
}
.slot.booked {
    background-color: #ef9a9a; /* Light red for booked slots */
    cursor: not-allowed;
    color: #333;
}

/* For slots that can be cancelled (either by self or admin) */
.slot.cancellable { /* New class 'cancellable' directly on .slot */
    position: relative; /* Needed for absolute positioning of child elements (cancel-icon) */
}

.slot.own {
    background-color: #a5d6a7; /* Light green for own bookings */
    cursor: pointer;
    color: #333;
}
.slot.booked.admin-override {
    background-color: #fdd835; /* Yellow for admin override */
    color: #333;
    cursor: pointer;
}

/* Styles for the "x" icon in cancellable slots */
.slot .cancel-icon { /* Applies to cancel-icon directly within .slot */
    position: absolute;
    top: 5px;
    right: 5px;
    font-size: 1.2em;
    font-weight: bold;
    color: #c62828; /* Red 'x' */
    opacity: 0; /* Hidden by default */
    transition: opacity 0.2s ease;
    pointer-events: none; /* Icon itself is not clickable, parent slot handles click */
    z-index: 10;
}

.slot.cancellable:hover .cancel-icon { /* Show on hover for any cancellable slot */
    opacity: 1;
}

.slot .slot-text {
    white-space: normal;
    word-wrap: break-word;
    text-overflow: clip;
    overflow: visible;
    width: calc(100% - 10px); /* Adjust width to leave some room for the 'x' if visible */
    box-sizing: border-box;
    text-align: center;
    padding: 0; /* No internal padding on text, slot handles it */
    line-height: 1.2;
}

.slot:hover:not(.booked):not(.own) {
    background-color: #c0c0c0;
    transform: translateY(-2px);
}

.slot.booked.admin-override:hover {
    background-color: #fbc02d;
}

/* Admin Panel Styling */
.adminPanel {
    margin-top: 30px;
    border-top: 2px solid #bcaaa4; /* Muted brown border */
    padding-top: 20px;
}

/* User Management in Admin Panel */
.user-management {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #ddd;
}
.user-management ul {
    list-style: none;
    padding: 0;
}
.user-management li {
    background: #fcfcfc;
    margin: 5px 0;
    padding: 10px 15px;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.user-management button {
    padding: 6px 12px;
    font-size: 0.9rem;
}

/* Delete Account Button Styling and Position (less prominent) */
.delete-account-container {
    text-align: center; /* Centered in the dashboard now */
    margin-top: 30px; /* More space from other elements */
    padding-top: 15px;
    border-top: 1px solid #eee;
}
#deleteAccountBtn {
    background-color: #bdbdbd !important; /* Muted grey */
    color: #555 !important;
    box-shadow: none !important; /* No shadow to make it less prominent */
}
#deleteAccountBtn:hover {
    background-color: #9e9e9e !important;
    transform: none !important; /* No lift effect */
    box-shadow: none !important;
}


/* Footer Styling */
footer {
    text-align: center;
    padding: 12px 0;
    color: #666;
    font-size: 0.9rem;
}

/* Custom Modal Styles */
#customModal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.5); /* Black w/ opacity */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
}

#customModal .modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Smaller width for modal */
    max-width: 400px; /* Max width for modal */
    border-radius: 10px;
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
    text-align: center;
    position: relative;
}

#customModal .modal-content button {
    margin: 5px;
    min-width: 80px;
}

#customModal .modal-content button#modalCancelBtn {
    background-color: #666;
}
#customModal .modal-content button#modalCancelBtn:hover {
    background-color: #555;
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    main {
        margin: 10px auto;
        padding: 15px;
        border-radius: 8px;
    }
    header h1 {
        font-size: 1.3rem;
    }
    input[type="text"],
    input[type="email"],
    input[type="password"] {
        width: calc(100% - 20px); /* Adjust for smaller padding */
        max-width: none; /* Allow full width on small screens */
    }
    .date-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 8px;
    }
    .time-slots {
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); /* Adjusted min-width for mobile */
        gap: 15px; /* Increased gap for mobile */
    }
    .slot {
        width: 80px; /* Fixed width for consistency on mobile */
        height: 65px; /* Fixed height for consistency on mobile */
        padding: 5px; /* Adjusted padding for mobile, total width 80+5+5 = 90px */
        font-size: 0.9em;
    }
    .slot .cancel-icon { /* Adjust icon size/position for mobile */
        font-size: 1em;
        top: 2px;
        right: 2px;
    }
    /* Adjust logout button for small screens */
    .current-user-info {
        flex-direction: column; /* Stack items vertically */
        align-items: flex-start; /* Align text to the left */
        padding-bottom: 10px;
    }
    .current-user-info #logoutBtn {
        margin-top: 10px; /* Add space when stacked */
        margin-left: 0;
        width: 100%; /* Make button full width */
    }
}

@media (max-width: 480px) {
    header {
        padding: 10px 15px;
    }
    header h1 {
        font-size: 1.2rem;
    }
    main {
        margin: 5px auto;
        padding: 10px;
    }
    button {
        padding: 10px 18px;
        font-size: 1rem;
    }
    .date-grid {
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    }
    .date-tile .date-day-number {
        font-size: 1.3rem;
    }
    .date-tile .date-weekday-abbr {
        font-size: 0.8rem;
    }
    .date-tile .date-month-abbr {
        font-size: 0.7rem;
    }
}
</style>
</head>
<body>

<header>
<h1>GENIUS Nachhilfe - Raumplanung</h1>
<p>Wolfgang-Heinze-Straße 6b, 18435 Stralsund</p>
</header>

<main>

<!-- Login Section -->
<section class="login" id="loginSection">
    <h2>Login</h2>
    <input type="email" id="loginEmailInput" placeholder="E-Mail" />
    <input type="password" id="loginPasswordInput" placeholder="Passwort" />
    <button id="loginBtn">Einloggen</button>
    <p class="error" id="loginError" style="display:none;"></p>
    <p class="form-switch-link" id="showRegisterLink">Noch kein Konto? Registrieren</p>
    <p class="form-switch-link" id="forgotPasswordLink" style="margin-top: 5px;">Passwort vergessen?</p>
</section>

<!-- Register Section -->
<section class="register" id="registerSection" style="display:none;">
    <h2>Registrieren</h2>
    <input type="text" id="registerNameInput" placeholder="Dein Name (z.B. Anna Müller)" />
    <input type="email" id="registerEmailInput" placeholder="E-Mail" />
    <input type="password" id="registerPasswordInput" placeholder="Passwort" />
    <input type="password" id="registerConfirmPasswordInput" placeholder="Passwort wiederholen" />
    <button id="registerBtn">Registrieren</button>
    <p class="error" id="registerError" style="display:none;"></p>
    <p class="form-switch-link" id="showLoginLink">Bereits ein Konto? Anmelden</p>
</section>

<!-- Dashboard Section -->
<section class="dashboard" style="display:none;">
    <div class="current-user-info">
        <div>
            Du bist eingeloggt als: <span id="userNameDisplay"></span>
            <span id="userApprovalStatus" style="margin-left: 10px; font-weight: bold;"></span>
        </div>
        <button id="logoutBtn">Ausloggen</button>
    </div>
    <h2>Termin buchen</h2>
    <p>Klicke auf ein Datum, um Zeiten zu sehen und dich ein- oder auszutragen.</p>
    <div class="room-selection">
        <input type="radio" id="room1" name="room" value="Raum 1" checked>
        <label for="room1">Raum 1</label>
        <input type="radio" id="room2" name="room" value="Raum 2">
        <label for="room2">Raum 2</label>
    </div>
    <div id="datesContainer" class="date-grid"></div>
    <div id="timeSlotsContainer" class="time-slots" style="display:none;"></div>
    <!-- Delete account button moved here -->
    <div class="delete-account-container">
        <button id="deleteAccountBtn">Konto löschen</button>
    </div>
</section>

<!-- Admin Panel Section -->
<section class="adminPanel" style="display:none;">
    <h2>Admin-Bereich</h2>
    <!-- Der Button "Alle Buchungen löschen" wurde entfernt -->

    <div class="user-management">
        <h3>Nachhilfelehrer-Verwaltung (Genehmigung)</h3>
        <p>Hier können Administratoren den Genehmigungsstatus der Nachhilfelehrer verwalten. Nur genehmigte Nachhilfelehrer können Termine buchen.</p>
        <ul id="userList"></ul>
    </div>
</section>

<!-- Custom Modal for Alerts and Confirmations -->
<div id="customModal">
    <div class="modal-content">
        <p id="modalMessage"></p>
        <!-- Geändert von modalPasswordInput zu modalTextInput und Placeholder-Text angepasst -->
        <input type="email" id="modalTextInput" style="display:none; margin: 10px auto;" placeholder="E-Mail eingeben" />
        <button id="modalConfirmBtn">Ja</button>
        <button id="modalCancelBtn">Abbrechen</button>
        <button id="modalOKBtn">OK</button>
    </div>
</div>

</main>

<footer>© 2025 GENIUS Nachhilfe Raumplaner</footer>

<script type="module">
// Corrected Firebase imports for modular SDK (updated to v11.6.1)
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, reauthenticateWithCredential, EmailAuthProvider, deleteUser, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"; // Added sendPasswordResetEmail
import { getFirestore, doc, getDoc, setDoc, deleteDoc, collection, onSnapshot, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// === Firebase-Konfiguration ===
// Wichtiger Hinweis: Wenn Sie den Fehler "auth/configuration-not-found" erhalten,
// stellen Sie sicher, dass "Email/Password" als Anmeldemethode in Ihrem Firebase-Projekt
// (Authentication -> Sign-in method) aktiviert ist.
// BITTE ERSETZEN SIE DIE PLATZHALTER MIT IHREN EIGENEN FIREBASE-INFORMATIONEN.
const firebaseConfig = {
    apiKey: "AIzaSyApOdRm_xgUhPbeBeFJ6NPHOt4LSBUJiIo", // ERSETZEN SIE DIES MIT IHREM EIGENEN API-SCHLÜSSEL
    authDomain: "genius-raumplaner.firebaseapp.com",
    databaseURL: "https://genius-raumplaner-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "genius-raumplaner",
    storageBucket: "genius-raumplaner.firebasestorage.app",
    messagingSenderId: "1081346940014",
    appId: "1:1081346940014:web:d6b00e0f7d3cd1fb125a7f"
};

// Initialize Firebase services
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// === Global Variables ===
let currentUser = null; // Stores authenticated user's display name
let currentUserEmail = null; // Stores authenticated user's email
let isAdmin = false;
let currentUserData = null; // Stores the full user document data from Firestore
const DAYS_TO_SHOW = 30; // Number of days to show for booking
let selectedDate = null; // Currently selected date in formateYYYY-MM-DD
let selectedRoom = 'Raum 1'; // Currently selected room

// Hardcoded admin names for explicit admin rights (for UI logic only)
// The actual admin check for security is done in Firestore Rules using UID.
// Make sure these names match the names of the UIDs you configure in Firestore Rules.
const ADMIN_NAMES = ["sascha birk", "jeanin birk", "nora"]; // Ensure these names match the names stored in Firestore (lowercase)

// === Utility function to capitalize the first letter of each word ===
function toTitleCase(str) {
    if (!str) return '';
    return str.split(' ').map(word => {
        if (word.length === 0) return '';
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    }).join(' ');
}

// === Custom Modal Functions ===
// This modal replaces standard browser alerts and confirms for better UI control.
let resolveModalPromise; // Used to resolve the promise when modal buttons are clicked

/**
 * Displays a custom modal dialog for alerts or confirmations.
 * @param {string} message - The message to display in the modal.
 * @param {string} type - 'alert' for an OK button, 'confirm' for Yes/No buttons, 'prompt' for a text input.
 * @returns {Promise<boolean|string>} - Resolves to true for OK/Yes, false for Cancel, or string for prompt input.
 */
function showModal(message, type = 'alert') {
    const customModal = document.getElementById('customModal');
    const modalMessage = document.getElementById('modalMessage');
    const modalConfirmBtn = document.getElementById('modalConfirmBtn');
    const modalCancelBtn = document.getElementById('modalCancelBtn');
    const modalOKBtn = document.getElementById('modalOKBtn');
    // Geändert von modalPasswordInput zu modalTextInput
    const modalTextInput = document.getElementById('modalTextInput');

    modalMessage.textContent = message;

    // Reset and hide all specific modal elements
    modalConfirmBtn.style.display = 'none';
    modalCancelBtn.style.display = 'none';
    modalOKBtn.style.display = 'none';
    // Geändert von modalPasswordInput zu modalTextInput
    modalTextInput.style.display = 'none'; // Hide text input by default
    modalTextInput.value = ''; // Clear input value

    return new Promise(resolve => {
        resolveModalPromise = resolve; // Store resolve function to be called by button click handlers

        if (type === 'confirm') {
            modalConfirmBtn.style.display = 'inline-block';
            modalCancelBtn.style.display = 'inline-block';
            modalConfirmBtn.onclick = () => {
                customModal.style.display = 'none';
                resolveModalPromise(true); // Resolve with true for confirm
            };
            modalCancelBtn.onclick = () => {
                customModal.style.display = 'none';
                resolveModalPromise(false); // Resolve with false for cancel
            };
        } else if (type === 'prompt') {
            // Geändert von modalPasswordInput zu modalTextInput
            modalTextInput.type = 'text'; // Ensure it's a text input
            modalTextInput.style.display = 'block'; // Show text input
            modalOKBtn.style.display = 'inline-block';
            modalOKBtn.onclick = () => {
                customModal.style.display = 'none';
                resolveModalPromise(modalTextInput.value); // Resolve with the input value
            };
        } else { // Default to 'alert' type
            modalOKBtn.style.display = 'inline-block';
            modalOKBtn.onclick = () => {
                customModal.style.display = 'none';
                resolveModalPromise(true); // Resolve with true for alert (just acknowledge)
            };
        }
        customModal.style.display = 'flex'; // Make the modal visible
    });
}

// === Firebase Auth State Listener ===
// This listener fires whenever the user's sign-in state changes (login, logout, initial load).
onAuthStateChanged(auth, async (user) => {
    if (user) {
        currentUserEmail = user.email;

        // Fetch the user's document from Firestore to get their name and approval status
        const userDocRef = doc(db, 'users', user.uid);
        const userDocSnap = await getDoc(userDocRef);

        if (userDocSnap.exists()) {
            currentUserData = userDocSnap.data(); // Store all user data including isApproved
            currentUser = currentUserData.name; // Use the name from Firestore
            // Check if current user's name is in the ADMIN_NAMES list for UI purposes
            isAdmin = ADMIN_NAMES.includes(currentUser.toLowerCase());
        } else {
            console.warn("User document not found for authenticated user:", user.uid);
            // If user document doesn't exist, sign them out as a security measure/cleanup
            await signOut(auth);
            return;
        }

        // Store user data in localStorage for persistence across page loads (client-side only)
        localStorage.setItem('currentUserUid', user.uid);
        localStorage.setItem('currentUser', currentUser);
        localStorage.setItem('isAdmin', isAdmin); // For UI, actual security by Firestore rules
        localStorage.setItem('currentUserData', JSON.stringify(currentUserData)); // Store full data

        showDashboard(); // Display the dashboard after successful login

        // Listen for real-time updates to the user's own document (especially isApproved status)
        onSnapshot(userDocRef, (doc) => {
            if (doc.exists()) {
                const prevIsApproved = currentUserData.isApproved; // Store previous status
                currentUserData = doc.data(); // Update with latest data
                isAdmin = ADMIN_NAMES.includes(currentUserData.name.toLowerCase()); // Re-evaluate admin for UI

                // If approval status changed, refresh UI for user and show a modal message
                if (prevIsApproved !== currentUserData.isApproved) {
                    showModal(`Dein Genehmigungsstatus wurde ${currentUserData.isApproved ? 'aktiviert' : 'deaktiviert'}.`, 'alert').then(() => {
                        if (selectedDate) {
                            selectDate(selectedDate); // Re-render time slots if approval status changes
                        }
                        updateUserApprovalStatusDisplay(); // Update display for current user
                    });
                } else if (selectedDate) {
                    // If selectedDate is already set and other data changed (e.g., name), re-render
                    selectDate(selectedDate);
                }
                updateUserApprovalStatusDisplay(); // Always update display when user data loads/changes
            }
        });

    } else {
        // User is logged out or not authenticated
        currentUser = null;
        currentUserEmail = null;
        isAdmin = false;
        currentUserData = null; // Clear user data
        // Clear localStorage
        localStorage.removeItem('currentUserUid');
        localStorage.removeItem('currentUser');
        localStorage.removeItem('isAdmin');
        localStorage.removeItem('currentUserData');
        showLogin(); // Show the login screen
    }
});

// Helper function to update the approval status display in the dashboard
const userApprovalStatusDisplay = document.getElementById('userApprovalStatus');
function updateUserApprovalStatusDisplay() {
    // Only show approval status if not an admin
    if (isAdmin) {
        userApprovalStatusDisplay.textContent = ""; // Admins don't need this status display
        return;
    }

    if (currentUserData) {
        if (currentUserData.isApproved) {
            userApprovalStatusDisplay.textContent = "(Genehmigt)";
            userApprovalStatusDisplay.style.color = "#2e7d32"; // Green for approved
        } else {
            userApprovalStatusDisplay.textContent = "(Warten auf Genehmigung)";
            userApprovalStatusDisplay.style.color = "#d32f2f"; // Red for pending approval
        }
    } else {
        userApprovalStatusDisplay.textContent = ""; // No user data, no status
    }
}

// === Firestore Data Operations ===

/**
 * Loads booking data for a specific date and room from Firestore.
 * @param {string} dateStr - The date in formateYYYY-MM-DD.
 * @param {string} room - The room name (e.g., "Raum 1").
 * @returns {Object} - An object containing time slot bookings.
 */
async function loadBookings(dateStr, room) {
    const bookingDocRef = doc(db, 'bookings', dateStr, 'rooms', room);
    const docSnap = await getDoc(bookingDocRef);
    return docSnap.exists() ? docSnap.data() : {}; // Return existing data or an empty object
}

/**
 * Toggles a time slot booking (book/unbook) for a user or allows admin to delete.
 * @param {string} dateStr - The date in formateYYYY-MM-DD.
 * @param {string} room - The room name.
 * @param {string} timeSlot - The time slot (e.g., "08:00").
 * @param {string} userDisplayName - The display name of the current user.
 * @param {boolean} isAdminUser - True if the current user is an admin.
 * @returns {string|null} - The name of the user who booked the slot, or null if unbooked.
 */
async function toggleBooking(dateStr, room, timeSlot, userDisplayName, isAdminUser) {
    // Client-side check: Only approved users or admins can book
    if (!currentUserData || (!currentUserData.isApproved && !isAdminUser)) {
        await showModal("Du bist noch nicht genehmigt, um Termine zu buchen. Bitte kontaktiere den Administrator.", 'alert');
        return;
    }

    const bookingDocRef = doc(db, 'bookings', dateStr, 'rooms', room);
    const currentBookings = await loadBookings(dateStr, room);

    // Scenario 1: User is deleting their own booked slot
    if (currentBookings[timeSlot] && currentBookings[timeSlot].toLowerCase() === userDisplayName.toLowerCase()) {
        // No confirmation for own unbooking, and no alert message
        delete currentBookings[timeSlot]; // Remove the booking
        await setDoc(bookingDocRef, currentBookings); // Update Firestore
        return null;
    }
    // Scenario 2: Admin is deleting someone else's booked slot - **REQUIRES CONFIRMATION**
    else if (currentBookings[timeSlot] && isAdminUser) {
        const bookedBy = toTitleCase(currentBookings[timeSlot]);
        const confirmed = await showModal(`Möchtest du die Buchung von ${bookedBy} um ${timeSlot} wirklich löschen?`, 'confirm');
        if (confirmed) {
            delete currentBookings[timeSlot]; // Remove the booking
            await setDoc(bookingDocRef, currentBookings); // Update Firestore
            await showModal(`Buchung von ${bookedBy} wurde erfolgreich gelöscht.`, 'alert');
        }
        return null; // Return null regardless of confirmation, let UI refresh
    }
    // Scenario 3: Slot is free, current user (approved or admin) wants to book it
    else if (!currentBookings[timeSlot]) {
        // No confirmation for booking, and no alert message
        currentBookings[timeSlot] = userDisplayName.toLowerCase(); // Store name in lowercase for consistent comparison
        await setDoc(bookingDocRef, currentBookings); // Update Firestore
        return userDisplayName;
    }
    // Scenario 4: Slot is booked by someone else, and current user is not an admin
    else {
        await showModal(`Dieser Termin ist bereits von ${toTitleCase(currentBookings[timeSlot])} gebucht!`, 'alert');
        return currentBookings[timeSlot];
    }
}

/**
 * Clears all bookings made by a specific user across all dates and rooms.
 * This is used when a user deletes their account.
 * @param {string} userDisplayName - The display name of the user whose bookings should be cleared.
 * @returns {number} - The count of bookings removed.
 */
async function clearUserBookings(userDisplayName) {
    const bookingsCollectionRef = collection(db, 'bookings');
    const bookingsSnapshot = await getDocs(bookingsCollectionRef); // Get all date documents

    const batch = writeBatch(db); // Use a batch for atomic operations and efficiency
    let bookingsRemovedCount = 0;

    for (const dateDoc of bookingsSnapshot.docs) {
        const dateStr = dateDoc.id;
        const roomsCollectionRef = collection(db, 'bookings', dateStr, 'rooms');
        const roomsSnapshot = await getDocs(roomsCollectionRef); // Get all room documents for this date

        for (const roomDoc of roomsSnapshot.docs) {
            const roomName = roomDoc.id;
            const currentBookings = roomDoc.data();
            let changed = false;
            const newBookings = { ...currentBookings }; // Create a mutable copy

            for (const slot in newBookings) {
                // Check if the slot is booked by the user to be cleared (case-insensitive)
                if (newBookings[slot].toLowerCase() === userDisplayName.toLowerCase()) {
                    delete newBookings[slot]; // Remove the booking
                    changed = true;
                    bookingsRemovedCount++;
                }
            }
            if (changed) {
                // If no slots remain for this room, delete the room document
                if (Object.keys(newBookings).length === 0) {
                    batch.delete(doc(db, 'bookings', dateStr, 'rooms', roomName));
                } else {
                    batch.set(doc(db, 'bookings', dateStr, 'rooms', roomName), newBookings);
                }
            }
        }
    }
    await batch.commit(); // Commit all batch operations
    return bookingsRemovedCount;
}

// Die Funktion clearAllBookings ist nicht mehr erforderlich, da der Button entfernt wurde.
// async function clearAllBookings() {
//     // ... (Funktionsinhalt hier) ...
// }

// === Date and Time Utility Functions ===

/**
 * Formats a Date object into a formateYYYY-MM-DD string.
 * @param {Date} date - The date object.
 * @returns {string} - Formatted date string.
 */
function formatDate(date) {
    return date.toISOString().split('T')[0];
}

/**
 * Gets the abbreviated weekday name for a given date.
 * @param {Date} date - The date object.
 * @returns {string} - Abbreviated weekday (e.g., "Mo").
 */
function getWeekday(date) {
    const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
    return days[date.getDay()];
}

/**
 * Gets the abbreviated month name for a given date.
 * @param {Date} date - The date object.
 * @returns {string} - Abbreviated month (e.g., "Jan").
 */
function getMonthAbbreviation(date) {
    const months = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
    return months[date.getMonth()];
}

/**
 * Generates a list of Date objects for the next `DAYS_TO_SHOW` days.
 * @returns {Date[]} - An array of Date objects.
 */
function generateDateList() {
    const dates = [];
    const today = new Date();
    for (let i = 0; i < DAYS_TO_SHOW; i++) {
        const d = new Date(today);
        d.setDate(today.getDate() + i);
        dates.push(d);
    }
    return dates;
}

    /**
     * Generates a list of time slot intervals from 06:00 to 20:00 in 30-minute steps.
     * @returns {string[]} - An array of time slot interval strings (e.g., "06:00 - 06:30").
     */
    function generateTimeSlots() {
        const slots = [];
        // Start bei 6 Uhr und gehe bis kurz vor 20 Uhr, um das 19:30 - 20:00 Intervall zu inkludieren.
        for (let h = 6; h < 20; h++) {
            // Erste Hälfte der Stunde (z.B. 06:00 - 06:30)
            let startHourFormatted = String(h).padStart(2, '0');
            let endHourFormatted = String(h).padStart(2, '0');

            slots.push(`${startHourFormatted}:00 - ${endHourFormatted}:30`);

            // Zweite Hälfte der Stunde (z.B. 06:30 - 07:00)
            // Hier muss die Endzeit die nächste volle Stunde sein
            let nextHour = h + 1;
            let nextHourFormatted = String(nextHour).padStart(2, '0');

            // Füge nur hinzu, wenn die nächste Stunde nicht 20:00 Uhr überschreitet.
            // Das letzte Intervall soll 19:30 - 20:00 sein.
            if (!(h === 19 && nextHour === 20)) { // Vermeide 19:30 - 20:00 hier, da es speziell behandelt wird.
                 slots.push(`${startHourFormatted}:30 - ${nextHourFormatted}:00`);
            }
        }
        // Füge das letzte Intervall 19:30 - 20:00 explizit hinzu
        slots.push("19:30 - 20:00"); 

        return slots;
    }

// === UI Element References ===
const loginSection = document.getElementById('loginSection');
const registerSection = document.getElementById('registerSection');
const dashboardSection = document.querySelector('.dashboard');
const adminSection = document.querySelector('.adminPanel');

const loginEmailInput = document.getElementById('loginEmailInput');
const loginPasswordInput = document.getElementById('loginPasswordInput');
const loginBtn = document.getElementById('loginBtn');
const loginError = document.getElementById('loginError');
const forgotPasswordLink = document.getElementById('forgotPasswordLink'); // New: Forgot password link

const registerNameInput = document.getElementById('registerNameInput');
const registerEmailInput = document.getElementById('registerEmailInput');
const registerPasswordInput = document.getElementById('registerPasswordInput');
const registerConfirmPasswordInput = document.getElementById('registerConfirmPasswordInput');
const registerBtn = document.getElementById('registerBtn');
const registerError = document.getElementById('registerError');

const showRegisterLink = document.getElementById('showRegisterLink');
const showLoginLink = document.getElementById('showLoginLink');

const userNameDisplay = document.getElementById('userNameDisplay');
const datesContainer = document.getElementById('datesContainer');
const timeSlotsContainer = document.getElementById('timeSlotsContainer');
const logoutBtn = document.getElementById('logoutBtn');
const deleteAccountBtn = document.getElementById('deleteAccountBtn'); // Reference to delete account button

// const clearAllBookingsBtn = document.getElementById('clearAllBookingsBtn'); // REFERENZ ENTFERNT
const userList = document.getElementById('userList'); // Reference for user approval management list
const room1Radio = document.getElementById('room1');
const room2Radio = document.getElementById('room2');

let bookingsForSelectedDate = {}; // Stores fetched bookings for the current selected date/room

// === UI Display Functions ===

/** Shows the login section and hides others. */
function showLogin() {
    loginSection.style.display = 'block';
    registerSection.style.display = 'none';
    dashboardSection.style.display = 'none';
    adminSection.style.display = 'none';
    loginError.style.display = 'none';
    registerError.style.display = 'none';
}

/** Shows the registration section and hides others. */
function showRegister() {
    loginSection.style.display = 'none';
    registerSection.style.display = 'block';
    dashboardSection.style.display = 'none';
    adminSection.style.display = 'none';
    loginError.style.display = 'none';
    registerError.style.display = 'none';
}

/** Shows the dashboard section and hides others, also renders dates and user info. */
function showDashboard() {
    loginSection.style.display = 'none';
    registerSection.style.display = 'none';
    dashboardSection.style.display = 'block';
    adminSection.style.display = isAdmin ? 'block' : 'none'; // Only show admin panel if user is admin
    userNameDisplay.textContent = toTitleCase(currentUser); // Display current user's name
    updateUserApprovalStatusDisplay(); // Update approval status text

    renderDates(); // Populate the date tiles
    if (selectedDate) {
        selectDate(selectedDate); // If a date was already selected, re-select it to refresh time slots
    }
    if (isAdmin) {
        renderUserList(); // Populate the user list in the admin panel
    }
}

// === Event Handlers ===

// Login button click handler
loginBtn.onclick = async () => {
    const email = loginEmailInput.value.trim();
    const password = loginPasswordInput.value.trim();
    loginError.style.display = 'none'; // Hide previous errors

    if (!email || !password) {
        loginError.textContent = "Bitte E-Mail und Passwort eingeben.";
        loginError.style.display = 'block';
        return;
    }

    try {
        await signInWithEmailAndPassword(auth, email, password);
        // onAuthStateChanged listener will handle UI update upon successful login
    } catch (error) {
        console.error("Login Error:", error.code, error.message);
        let errorMessage = "Anmeldung fehlgeschlagen. Überprüfen Sie Ihre E-Mail und Ihr Passwort.";
        if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
            errorMessage = "Ungültige E-Mail oder falsches Passwort.";
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = "Ungültiges E-Mail-Format.";
        }
        loginError.textContent = errorMessage;
        loginError.style.display = 'block';
    }
};

// Forgot Password link click handler
forgotPasswordLink.onclick = async () => {
    // Prompt for email using the custom modal
    const email = await showModal("Bitte geben Sie Ihre E-Mail-Adresse ein, um Ihr Passwort zurückzusetzen.", 'prompt');

    if (!email) {
        // User cancelled the prompt or entered an empty string
        await showModal("E-Mail zur Passwortrücksetzung erforderlich.", 'alert');
        return;
    }

    // Basic email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        await showModal("Ungültiges E-Mail-Format. Bitte geben Sie eine gültige E-Mail-Adresse ein.", 'alert');
        return;
    }

    try {
        await sendPasswordResetEmail(auth, email);
        await showModal(`Eine E-Mail zum Zurücksetzen des Passworts wurde an ${email} gesendet. Bitte überprüfen Sie Ihren Posteingang.`, 'alert');
    } catch (error) {
        console.error("Password Reset Error:", error.code, error.message);
        let errorMessage = "Fehler beim Zurücksetzen des Passworts.";
        if (error.code === 'auth/user-not-found') {
            errorMessage = "Es gibt kein Konto mit dieser E-Mail-Adresse.";
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = "Ungültiges E-Mail-Format.";
        }
        await showModal(errorMessage, 'alert');
    }
};


// Registration button click handler
registerBtn.onclick = async () => {
    const name = registerNameInput.value.trim();
    const email = registerEmailInput.value.trim();
    const password = registerPasswordInput.value.trim();
    const confirmPassword = registerConfirmPasswordInput.value.trim();
    registerError.style.display = 'none'; // Hide previous errors

    if (!name || !email || !password || !confirmPassword) {
        registerError.textContent = "Bitte füllen Sie alle Felder aus.";
        registerError.style.display = 'block';
        return;
    }
    if (password.length < 6) {
        registerError.textContent = "Passwort muss mindestens 6 Zeichen lang sein.";
        registerError.style.display = 'block';
        return;
    }
    if (password !== confirmPassword) {
        registerError.textContent = "Passwörter stimmen nicht überein.";
        registerError.style.display = 'block';
        return;
    }

    try {
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;

        // Save user's name to Firestore 'users' collection with isApproved: false
        // Store name in lowercase to ensure consistent comparison with Firestore rules and ADMIN_NAMES
        await setDoc(doc(db, 'users', user.uid), {
            name: name.toLowerCase(), // Store name in lowercase
            email: email,
            uid: user.uid,
            isTeacher: true, // All registered users are teachers by default in this context
            isApproved: false // User is unapproved by default, requires admin approval
        });

        await showModal("Registrierung erfolgreich! Sie sind jetzt angemeldet. Bitte warten Sie auf die Genehmigung durch einen Administrator, um Termine buchen zu können.", 'alert');
        // onAuthStateChanged will handle UI update upon successful registration and login
    } catch (error) {
        console.error("Registration Error:", error.code, error.message);
        let errorMessage = "Registrierung fehlgeschlagen.";
        if (error.code === 'auth/email-already-in-use') {
            errorMessage = "Diese E-Mail-Adresse ist bereits registriert.";
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = "Ungültiges E-Mail-Format.";
        } else if (error.code === 'auth/weak-password') {
            errorMessage = "Passwort ist zu schwach (min. 6 Zeichen).";
        } else if (error.code === 'auth/configuration-not-found') {
            errorMessage = "Registrierung fehlgeschlagen. Bitte aktivieren Sie die 'Email/Password'-Anmeldemethode in Ihrer Firebase Console unter 'Authentication' -> 'Sign-in method'.";
        }
        registerError.textContent = errorMessage;
        registerError.style.display = 'block';
    }
};

// Toggle between login and register forms
showRegisterLink.onclick = showRegister;
showLoginLink.onclick = showLogin;

// Logout button click handler (moved to be next to user info)
// The button element is moved in the HTML. The event handler remains the same.
logoutBtn.onclick = async () => {
    try {
        await signOut(auth);
        // onAuthStateChanged will handle UI update, no modal needed here
    } catch (error) {
        console.error("Logout Error:", error.message);
        await showModal("Fehler beim Abmelden: " + error.message, 'alert');
    }
};

// Delete current user's account button click handler
deleteAccountBtn.onclick = async () => {
    if (!auth.currentUser) {
        await showModal("Sie sind nicht angemeldet.", 'alert');
        return;
    }

    // Confirm deletion with the user
    const confirmed = await showModal("Möchten Sie Ihr Konto wirklich löschen? Dies kann nicht rückgängig gemacht werden. Alle Ihre Daten und Buchungen werden gelöscht.", 'confirm');
    if (!confirmed) {
        return; // User cancelled
    }

    const email = currentUserEmail; // Get email from the current session
    // Prompt for password for re-authentication, which is required for sensitive operations like account deletion
    const password = await showModal("Bitte geben Sie Ihr Passwort zur Bestätigung ein:", 'prompt'); // Using custom modal for prompt input
    if (!password) {
        await showModal("Passwort zur Bestätigung erforderlich.", 'alert');
        return;
    }

    try {
        // Re-authenticate the user with their email and password
        const credential = EmailAuthProvider.credential(email, password);
        await reauthenticateWithCredential(auth.currentUser, credential);

        const userUid = auth.currentUser.uid;
        const userDisplayName = currentUser;

        // 1. Delete user's document from 'users' collection in Firestore
        await deleteDoc(doc(db, 'users', userUid));

        // 2. Clear all bookings made by this user from the 'bookings' collection
        await clearUserBookings(userDisplayName);

        // 3. Delete the Firebase Authentication account itself
        await deleteUser(auth.currentUser);

        await showModal("Ihr Konto und alle zugehörigen Daten wurden erfolgreich gelöscht.", 'alert');
        // onAuthStateChanged will handle UI update and sign out automatically after account deletion
    } catch (error) {
        console.error("Account deletion error:", error.code, error.message);
        let errorMessage = "Fehler beim Löschen des Kontos.";
        if (error.code === 'auth/requires-recent-login') {
            errorMessage = "Diese Aktion erfordert eine kürzliche Anmeldung. Bitte melden Sie sich erneut an und versuchen Sie es noch einmal.";
        } else if (error.code === 'auth/wrong-password') {
            errorMessage = "Falsches Passwort. Konto konnte nicht gelöscht werden.";
        } else if (error.code === 'auth/user-mismatch' || error.code === 'auth/invalid-credential') {
            errorMessage = "Ungültige Anmeldeinformationen für die Reauthentifizierung.";
        } else if (error.code === 'auth/network-request-failed') {
            errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
        }
        await showModal(errorMessage, 'alert');
    }
};

/**
 * Renders the date tiles in the dashboard.
 */
function renderDates() {
    datesContainer.innerHTML = ''; // Clear existing dates
    const dates = generateDateList(); // Get the next 30 days

    dates.forEach(date => {
        const dateStr = formatDate(date); // Format date toYYYY-MM-DD
        const dayNumber = String(date.getDate()).padStart(2, '0');
        const weekdayAbbr = getWeekday(date);
        const monthAbbr = getMonthAbbreviation(date);

        const div = document.createElement('div');
        div.className = 'date-tile';
        div.dataset.date = dateStr; // Store the full date string as a data attribute

        const daySpan = document.createElement('span');
        daySpan.className = 'date-day-number';
        daySpan.textContent = dayNumber;

        const weekdaySpan = document.createElement('span');
        weekdaySpan.className = 'date-weekday-abbr';
        weekdaySpan.textContent = weekdayAbbr;

        const monthSpan = document.createElement('span');
        monthSpan.className = 'date-month-abbr';
        monthSpan.textContent = monthAbbr;

        div.appendChild(daySpan);
        div.appendChild(weekdaySpan);
        div.appendChild(monthSpan);

        div.onclick = () => selectDate(dateStr); // Attach click event to select date

        datesContainer.appendChild(div);
    });
}

/**
 * Selects a date, highlights it, fetches bookings, and renders time slots.
 * @param {string} dateStr - The date string in formateYYYY-MM-DD.
 */
async function selectDate(dateStr) {
    selectedDate = dateStr; // Set the globally selected date
    highlightSelectedDate(); // Apply 'selected' class to the chosen date tile

    // Load bookings for the newly selected date and current room
    bookingsForSelectedDate = await loadBookings(selectedDate, selectedRoom);
    renderTimeSlots(); // Render the time slots based on fetched bookings
}

/**
 * Highlights the currently selected date tile.
 */
function highlightSelectedDate() {
    [...datesContainer.children].forEach(div => {
        div.classList.toggle('selected', div.dataset.date === selectedDate);
    });
}

/**
 * Renders the time slots for the selected date and room, showing booking status.
 */
function renderTimeSlots() {
    timeSlotsContainer.innerHTML = ''; // Clear existing time slots
    timeSlotsContainer.style.display = 'grid'; // Ensure grid display for consistency

    const slots = generateTimeSlots(); // Get all possible time slots

    slots.forEach(slot => {
        const bookingUser = bookingsForSelectedDate[slot]; // Get who booked this slot, if anyone
        const slotDiv = document.createElement('div');
        slotDiv.className = 'slot';

        if (bookingUser) {
            // Split name into first and last name(s)
            let displayNameParts = toTitleCase(bookingUser).split(' ');
            let firstName = displayNameParts[0];
            let lastName = displayNameParts.length > 1 ? displayNameParts.slice(1).join(' ') : '';
            let displayHtml = lastName ? `${firstName}<br>${lastName}` : firstName; // Use <br> for line break

            // If the slot is booked
            if (currentUser && bookingUser.toLowerCase() === currentUser.toLowerCase()) {
                slotDiv.classList.add('own', 'cancellable'); // Booked by current user, and cancellable
                slotDiv.title = 'Klicke zum Austragen'; // Hint for unbooking
                // Use innerHTML to include text and a hidden 'x' icon
                slotDiv.innerHTML = `<span class="slot-text">${displayHtml}</span><span class="cancel-icon">x</span>`;
            } else if (isAdmin) {
                // Admin can see the 'x' on all booked slots not just their own
                slotDiv.classList.add('booked', 'admin-override', 'cancellable'); // Booked by someone else, admin can override, and cancellable
                slotDiv.title = `Gebucht von ${toTitleCase(bookingUser)} (Klicke zum Löschen)`;
                slotDiv.innerHTML = `<span class="slot-text">${displayHtml}</span><span class="cancel-icon">x</span>`; // Add icon here too
            } else {
                slotDiv.classList.add('booked'); // Booked by someone else, not admin
                slotDiv.title = 'Bereits gebucht';
                // Wrap in slot-text for consistent styling even if not cancellable
                slotDiv.innerHTML = `<span class="slot-text">${displayHtml}</span>`;
            }
        } else {
            // If the slot is free
            slotDiv.textContent = slot; // Display the time slot itself
            // Determine if the slot is clickable based on user approval/admin status
            if (currentUserData && currentUserData.isApproved || isAdmin) {
                slotDiv.title = 'Klicke zum Eintragen'; // Hint for booking
            } else {
                slotDiv.title = 'Nicht genehmigt (zum Buchen Administrator kontaktieren)';
                slotDiv.style.cursor = 'not-allowed'; // Visual cue that it's not clickable
                slotDiv.classList.add('booked'); // Grey out slightly if not approved (visually as "booked")
            }
        }

        // Add click handler based on permissions
        if (currentUserData && (currentUserData.isApproved || isAdmin) && (!bookingUser || bookingUser.toLowerCase() === currentUser.toLowerCase() || isAdmin)) {
            // Slot is clickable if it's free, or booked by current user, or current user is admin
            slotDiv.style.cursor = 'pointer';
            slotDiv.onclick = async () => {
                if (!currentUser) {
                    await showModal("Bitte logge dich zuerst ein, um einen Slot zu buchen.", 'alert');
                    return;
                }
                // Call the toggle booking function, which handles all logic (booking, unbooking, admin override)
                await toggleBooking(selectedDate, selectedRoom, slot, currentUser, isAdmin);
                // Re-fetch and re-render time slots after any action to show updated status
                bookingsForSelectedDate = await loadBookings(selectedDate, selectedRoom);
                renderTimeSlots();
            };
        } else if (!currentUserData || (!currentUserData.isApproved && !isAdmin)) {
            // If not approved and not admin, show an alert on click
            slotDiv.onclick = () => showModal("Du bist noch nicht genehmigt, um Termine zu buchen. Bitte kontaktiere den Administrator.", 'alert');
        }

        timeSlotsContainer.appendChild(slotDiv); // Add the slot to the container
    });
}

// Admin Button: Clear All Bookings - ENTFERNT
// clearAllBookingsBtn.onclick = async () => {
//     await clearAllBookings();
// };

/**
 * Renders the list of users in the admin panel for approval management.
 * Only visible to admins.
 */
async function renderUserList() {
    if (!isAdmin) { // Ensure only admins can see and interact with this
        userList.innerHTML = '';
        return;
    }
    userList.innerHTML = '<li>Lade Benutzer...</li>'; // Loading indicator

    const usersCollectionRef = collection(db, 'users');
    // Get all user documents. For large applications, consider pagination.
    const usersSnapshot = await getDocs(usersCollectionRef);

    userList.innerHTML = ''; // Clear loading indicator

    if (usersSnapshot.empty) {
        userList.innerHTML = '<li>Keine Benutzer gefunden.</li>';
        return;
    }

    usersSnapshot.forEach(userDoc => {
        const userData = userDoc.data();
        // Do not show the currently logged-in admin in the list for approval
        if (userData.uid === auth.currentUser.uid) return;

        const li = document.createElement('li');
        li.style.display = 'flex';
        li.style.justifyContent = 'space-between';
        li.style.alignItems = 'center';
        li.style.padding = '8px 10px';
        li.style.margin = '5px 0';
        li.style.backgroundColor = '#f0f0f0';
        li.style.borderRadius = '8px';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = toTitleCase(userData.name);
        li.appendChild(nameSpan);

        const statusSpan = document.createElement('span');
        statusSpan.textContent = userData.isApproved ? 'Aktiviert' : 'Deaktiviert';
        statusSpan.style.color = userData.isApproved ? '#2e7d32' : '#d32f2f'; // Green for active, red for inactive
        statusSpan.style.fontWeight = 'bold';
        li.appendChild(statusSpan);

        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = userData.isApproved ? 'Deaktivieren' : 'Aktivieren';
        toggleBtn.style.marginLeft = '10px';
        toggleBtn.style.backgroundColor = userData.isApproved ? '#ef5350' : '#4caf50'; // Red for deactivate, green for activate
        toggleBtn.onclick = async () => {
            // Confirm with admin before changing status
            const confirmed = await showModal(`Möchtest du "${toTitleCase(userData.name)}" ${userData.isApproved ? 'deaktivieren' : 'aktivieren'}?`, 'confirm');
            if (confirmed) {
                try {
                    // Update the `isApproved` status of the target user's document in Firestore
                    await setDoc(doc(db, 'users', userDoc.id), { isApproved: !userData.isApproved }, { merge: true });
                    await showModal(`${toTitleCase(userData.name)} wurde ${userData.isApproved ? 'deaktiviert' : 'aktiviert'}.`, 'alert');
                    renderUserList(); // Re-render the list to show updated status
                } catch (error) {
                    console.error("Error toggling user approval:", error);
                    await showModal("Fehler beim Ändern des Status: " + error.message, 'alert');
                }
            }
        };
        li.appendChild(toggleBtn);

        userList.appendChild(li); // Add user item to the list
    });
}

// Event listeners for room selection radio buttons
room1Radio.addEventListener('change', () => {
    selectedRoom = 'Raum 1';
    if (selectedDate) {
        selectDate(selectedDate); // Re-render time slots for the new room
    }
});

room2Radio.addEventListener('change', () => {
    selectedRoom = 'Raum 2';
    if (selectedDate) {
        selectDate(selectedDate); // Re-render time slots for the new room
    }
});

// Initial load is handled by onAuthStateChanged, which determines whether to show login or dashboard.
// No separate `init()` function call is needed as onAuthStateChanged fires on page load.
</script>
</body>
</html>
